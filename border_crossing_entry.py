# -*- coding: utf-8 -*-
"""border_crossing_entry.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Gcd7tblHVxs3_0QqoIhZ-G4hKg7AbCnJ
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the dataset
df = pd.read_csv('Border_Crossing_Entry_Data.csv')

# View basic info about the dataset
print(df.info())

# Check for missing values
print(df.isnull().sum())


# Convert 'Date' column to datetime objects
df['Date'] = pd.to_datetime(df['Date'])

# Extract year and month for analysis
df['Year'] = df['Date'].dt.year
df['Month'] = df['Date'].dt.month

# Summary statistics of the 'Value' column (number of crossings)
print(df['Value'].describe())

# Total traffic per port
port_traffic = df.groupby('Port Name')['Value'].sum().sort_values(ascending=False).head(10)

# Plot
plt.figure(figsize=(10, 6))
sns.barplot(x=port_traffic.values, y=port_traffic.index, palette='viridis')
plt.title('Top 10 Ports by Traffic Volume', fontsize=16, fontweight='bold')
plt.xlabel('Total Crossings', fontsize=14)
plt.ylabel('Port Name', fontsize=14)
plt.show()

# Traffic trend by month and year
traffic_by_month = df.groupby(['Year', 'Month'])['Value'].sum().reset_index()

# Pivot to visualize traffic over time
traffic_pivot = traffic_by_month.pivot(index='Month', columns='Year', values='Value')

# Heatmap of traffic by month and year
plt.figure(figsize=(12, 8))
sns.heatmap(traffic_pivot, cmap='coolwarm', annot=True, fmt=".0f")
plt.title('Heatmap of Border Traffic by Month and Year', fontsize=16, fontweight='bold')
plt.xlabel('Year', fontsize=14)
plt.ylabel('Month', fontsize=14)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Assuming df already has 'Year', 'Month', and 'Value' columns
# Group traffic by year and month
traffic_by_month = df.groupby(['Year', 'Month'])['Value'].sum().reset_index()

# Pivot table for heatmap (Month as row, Year as column)
traffic_pivot = traffic_by_month.pivot(index='Month', columns='Year', values='Value')

# Optional: Replace numeric month with month names for readability
month_names = {1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr', 5: 'May', 6: 'Jun',
               7: 'Jul', 8: 'Aug', 9: 'Sep', 10: 'Oct', 11: 'Nov', 12: 'Dec'}
traffic_pivot.rename(index=month_names, inplace=True)

# Set figure size dynamically based on the number of years and months
plt.figure(figsize=(max(10, len(traffic_pivot.columns) * 1.2), 8))

# Create heatmap with enhanced readability
sns.heatmap(
    traffic_pivot,
    cmap=sns.color_palette("YlGnBu", as_cmap=True),
    annot=True,
    fmt="d",  # Display whole numbers
    annot_kws={"size": 12, "fontweight": 'bold'},  # Larger font for annotations
    linewidths=0.5,  # Add small gaps between cells
    linecolor='lightgray',  # Color of the grid lines
    cbar_kws={"shrink": 0.75}  # Resize the color bar
)

# Title and labels with larger fonts
plt.title('Heatmap of Border Traffic by Month and Year', fontsize=18, fontweight='bold', pad=20)
plt.xlabel('Year', fontsize=14, fontweight='bold')
plt.ylabel('Month', fontsize=14, fontweight='bold')

# Use tight layout to prevent clipping
plt.tight_layout()

# Show the plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Assuming df already has 'Year', 'Month', and 'Value' columns
# Group traffic by year and month
traffic_by_month = df.groupby(['Year', 'Month'])['Value'].sum().reset_index()

# Pivot table for heatmap (Month as row, Year as column)
traffic_pivot = traffic_by_month.pivot(index='Month', columns='Year', values='Value')

# Optional: Replace numeric month with month names for readability
month_names = {1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr', 5: 'May', 6: 'Jun',
               7: 'Jul', 8: 'Aug', 9: 'Sep', 10: 'Oct', 11: 'Nov', 12: 'Dec'}
traffic_pivot.rename(index=month_names, inplace=True)

# Set figure size dynamically based on the number of years and months
plt.figure(figsize=(max(10, len(traffic_pivot.columns) * 1.2), 8))

# Create heatmap with enhanced readability
sns.heatmap(
    traffic_pivot,
    cmap=sns.color_palette("YlGnBu", as_cmap=True),
    annot=True,
    fmt=".0f",  # Changed from "d" to ".0f" to display floats with no decimal places
    annot_kws={"size": 12, "fontweight": 'bold'},  # Larger font for annotations
    linewidths=0.5,  # Add small gaps between cells
    linecolor='lightgray',  # Color of the grid lines
    cbar_kws={"shrink": 0.75}  # Resize the color bar
)

# Title and labels with larger fonts
plt.title('Heatmap of Border Traffic by Month and Year', fontsize=18, fontweight='bold', pad=20)
plt.xlabel('Year', fontsize=14, fontweight='bold')
plt.ylabel('Month', fontsize=14, fontweight='bold')

# Use tight layout to prevent clipping
plt.tight_layout()

# Show the plot
plt.show()

import folium
from folium.plugins import HeatMap

# Create base map
base_map = folium.Map(location=[31.9686, -99.9018], zoom_start=6)  # Texas region

# Filter data for visualization
df_map = df[['Latitude', 'Longitude', 'Value']].dropna()

# Create heatmap
heat_data = [[row['Latitude'], row['Longitude'], row['Value']] for index, row in df_map.iterrows()]
HeatMap(heat_data).add_to(base_map)

# Display map
base_map.save('border_traffic_heatmap.html')

import matplotlib.pyplot as plt
import seaborn as sns

# Count of traffic by Measure
measure_traffic = df.groupby('Measure')['Value'].sum().sort_values(ascending=False)

# Create a figure size that scales with the number of measures (dynamic width)
plt.figure(figsize=(max(10, len(measure_traffic) * 0.75), 6))

# Create the barplot with a cool, readable color palette
sns.barplot(x=measure_traffic.index, y=measure_traffic.values, palette='coolwarm')

# Add labels to the top of each bar
for i, value in enumerate(measure_traffic.values):
    plt.text(i, value + (value * 0.01), f'{value:,}', ha='center', va='bottom', fontsize=10, fontweight='bold', color='black')

# Set titles and labels with proper font sizes
plt.title('Traffic by Vehicle Type (e.g., Buses, Trucks, etc.)', fontsize=16, fontweight='bold', pad=20)
plt.xlabel('Vehicle Type (Measure)', fontsize=14, fontweight='bold')
plt.ylabel('Total Traffic', fontsize=14, fontweight='bold')

# Rotate x-axis labels for better readability
plt.xticks(rotation=45, ha='right', fontsize=12)

# Add gridlines for better readability
plt.grid(axis='y', linestyle='--', alpha=0.6)

# Tight layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

# Filter by measure (e.g., 'Buses')
buses_df = df[df['Measure'] == 'Buses']

# Get top 5 ports for buses
top_ports_buses = buses_df.groupby('Port Name')['Value'].sum().sort_values(ascending=False).head(5)

# Plot
plt.figure(figsize=(10, 6))
sns.barplot(x=top_ports_buses.values, y=top_ports_buses.index, palette='magma')
plt.title('Top 5 Ports by Number of Buses', fontsize=16, fontweight='bold')
plt.xlabel('Total Buses', fontsize=14)
plt.ylabel('Port Name', fontsize=14)
plt.show()

from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error

# Aggregate data at the monthly level
monthly_traffic = df.groupby('Date')['Value'].sum()

# Fit ARIMA model
model = ARIMA(monthly_traffic, order=(5, 1, 0))  # ARIMA(p, d, q)
model_fit = model.fit()

# Forecast next 12 months
forecast = model_fit.forecast(steps=12)

# Plot actual and forecasted values
plt.figure(figsize=(10, 6))
plt.plot(monthly_traffic, label='Actual')
plt.plot(forecast, label='Forecast', color='red')
plt.title('Traffic Forecast for the Next 12 Months', fontsize=16, fontweight='bold')
plt.xlabel('Date', fontsize=14)
plt.ylabel('Number of Crossings', fontsize=14)
plt.legend()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.seasonal import seasonal_decompose
# Convert 'Date' column to datetime objects
df['Date'] = pd.to_datetime(df['Date'])
monthly_traffic = df.groupby('Date')['Value'].sum()

# Decompose time series
decomposition = seasonal_decompose(monthly_traffic, model='additive', period=12)  # 12 months in a year

# Plot decomposition
plt.figure(figsize=(10, 8))
decomposition.plot()
plt.suptitle('Time Series Decomposition of Border Traffic', fontsize=16)
plt.show()

import plotly.graph_objects as go

# Prepare data for Sankey (simplified example)
df_subset = df.groupby(['Port Name', 'Border', 'Measure'])['Value'].sum().reset_index()

# Create source, target, and value lists
sources = df_subset['Port Name'].values.tolist()
targets = df_subset['Measure'].values.tolist()
values = df_subset['Value'].values.tolist()

# Assign indices to the nodes
unique_nodes = list(set(sources + targets))
source_indices = [unique_nodes.index(s) for s in sources]
target_indices = [unique_nodes.index(t) for t in targets]

# Create Sankey diagram
sankey_figure = go.Figure(go.Sankey(
    node=dict(
        pad=15,
        thickness=20,
        line=dict(color="black", width=0.5),
        label=unique_nodes
    ),
    link=dict(
        source=source_indices,
        target=target_indices,
        value=values
    )
))

sankey_figure.update_layout(title_text="Sankey Diagram of Traffic Flow (Port to Measure)", font_size=12)
sankey_figure.show()

from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

# Extract relevant features (latitude, longitude, total traffic)
df_cluster = df.groupby(['Port Name', 'Latitude', 'Longitude'])['Value'].sum().reset_index()

# Run KMeans clustering
X = df_cluster[['Latitude', 'Longitude']]
kmeans = KMeans(n_clusters=5, random_state=42).fit(X)
df_cluster['Cluster'] = kmeans.labels_

# Plot Clusters
plt.figure(figsize=(10, 6))
plt.scatter(df_cluster['Longitude'], df_cluster['Latitude'], c=df_cluster['Cluster'], cmap='viridis', s=df_cluster['Value'] / 100, alpha=0.6)
plt.colorbar(label='Cluster')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Geographic Clustering of High-Traffic Ports')
plt.show()

import folium

# Create a base map centered on US-Mexico border
base_map = folium.Map(location=[31.9686, -99.9018], zoom_start=6)

# Add traffic points to the map
for index, row in df.iterrows():
    folium.CircleMarker(
        location=[row['Latitude'], row['Longitude']],
        radius=row['Value'] / 1000,  # Scale traffic counts
        popup=f"Port: {row['Port Name']}<br>Value: {row['Value']}",
        color='crimson',
        fill=True,
        fill_color='crimson'
    ).add_to(base_map)

# Save and show map
base_map.save('border_traffic_map.html')

from sklearn.ensemble import IsolationForest

# Aggregate traffic data by port and date
df_traffic = df.groupby(['Date', 'Port Name'])['Value'].sum().reset_index()

# Fit Isolation Forest for anomaly detection
X = df_traffic[['Value']]
iso_forest = IsolationForest(contamination=0.02)  # Flag 2% of data as anomalies
df_traffic['Anomaly'] = iso_forest.fit_predict(X)

# Plot anomalies
plt.figure(figsize=(10, 6))
plt.plot(df_traffic['Date'], df_traffic['Value'], label='Traffic')
plt.scatter(df_traffic.loc[df_traffic['Anomaly'] == -1]['Date'],
            df_traffic.loc[df_traffic['Anomaly'] == -1]['Value'],
            color='red', label='Anomaly')
plt.title('Anomaly Detection in Border Traffic')
plt.xlabel('Date')
plt.ylabel('Number of Crossings')
plt.legend()
plt.show()

import seaborn as sns

# Extract month and value for each record
df['Month'] = df['Date'].dt.month
monthly_traffic = df.groupby(['Month'])['Value'].sum().reset_index()

# Boxplot for monthly traffic variability
plt.figure(figsize=(10, 6))
sns.boxplot(x='Month', y='Value', data=df)
plt.title('Monthly Variability in Border Traffic')
plt.xlabel('Month')
plt.ylabel('Traffic Volume')
plt.show()

# Pivot table for port, measure, and traffic value
pivot_df = df.pivot_table(index='Port Name', columns='Measure', values='Value', aggfunc='sum').fillna(0)

# Plot heatmap
plt.figure(figsize=(12, 6))
sns.heatmap(pivot_df, cmap='coolwarm', annot=True, fmt='.0f')
plt.title('Correlation Between Port and Measures')
plt.xlabel('Measure')
plt.ylabel('Port Name')
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Pivot table for port, measure, and traffic value
pivot_df = df.pivot_table(index='Port Name', columns='Measure', values='Value', aggfunc='sum').fillna(0)

# Dynamically adjust figure size based on the number of ports and measures
plt.figure(figsize=(max(12, len(pivot_df.columns) * 1.2), max(8, len(pivot_df.index) * 0.6)))

# Create heatmap with better readability
sns.heatmap(
    pivot_df,
    cmap=sns.color_palette("YlGnBu", as_cmap=True),
    annot=True,
    fmt="d",  # Display whole numbers only
    annot_kws={"size": 12, "fontweight": 'bold'},  # Bigger, bold font for annotations
    linewidths=0.5,  # Small gaps between cells
    linecolor='lightgray'  # Light gray gridlines
)

# Title and axis labels with larger fonts
plt.title('Correlation Between Port and Measures', fontsize=18, fontweight='bold', pad=20)
plt.xlabel('Measure', fontsize=14, fontweight='bold')
plt.ylabel('Port Name', fontsize=14, fontweight='bold')

# Use tight layout to prevent clipping of labels
plt.tight_layout()

# Show the plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Pivot table for port, measure, and traffic value
pivot_df = df.pivot_table(index='Port Name', columns='Measure', values='Value', aggfunc='sum').fillna(0)

# Dynamically adjust figure size based on the number of ports and measures
plt.figure(figsize=(max(12, len(pivot_df.columns) * 1.2), max(8, len(pivot_df.index) * 0.6)))

# Create heatmap with better readability
sns.heatmap(
    pivot_df,
    cmap=sns.color_palette("YlGnBu", as_cmap=True),
    annot=True,
    fmt=".0f",  # Changed from "d" to ".0f" to display floats with no decimal places
    annot_kws={"size": 12, "fontweight": 'bold'},  # Bigger, bold font for annotations
    linewidths=0.5,  # Small gaps between cells
    linecolor='lightgray'  # Light gray gridlines
)

# Title and axis labels with larger fonts
plt.title('Correlation Between Port and Measures', fontsize=18, fontweight='bold', pad=20)
plt.xlabel('Measure', fontsize=14, fontweight='bold')
plt.ylabel('Port Name', fontsize=14, fontweight='bold')

# Use tight layout to prevent clipping of labels
plt.tight_layout()

# Show the plot
plt.show()

import plotly.graph_objects as go

# Prepare data for Sankey (simplified example)
df_subset = df.groupby(['Port Name', 'Border', 'Measure'])['Value'].sum().reset_index()

# Create source, target, and value lists
sources = df_subset['Port Name'].values.tolist()
targets = df_subset['Measure'].values.tolist()
values = df_subset['Value'].values.tolist()

# Assign indices to the nodes
unique_nodes = list(set(sources + targets))
source_indices = [unique_nodes.index(s) for s in sources]
target_indices = [unique_nodes.index(t) for t in targets]

# Create Sankey diagram
sankey_figure = go.Figure(go.Sankey(
    node=dict(
        pad=15,
        thickness=20,
        line=dict(color="black", width=0.5),
        label=unique_nodes
    ),
    link=dict(
        source=source_indices,
        target=target_indices,
        value=values
    )
))

# Update layout with title and font size
sankey_figure.update_layout(
    title_text="Sankey Diagram of Traffic Flow (Port to Measure)",
    font_size=12
)

# Save the Sankey diagram as an HTML file
sankey_figure.write_html("sankey_diagram.html")

# Display the figure in the Jupyter Notebook / Python IDE
sankey_figure.show()

import plotly.express as px

# Summarize traffic data for each port and measure
port_traffic = df.groupby(['Port Name', 'Measure'])['Value'].sum().reset_index()

# Bubble plot using Plotly Express
fig = px.scatter(port_traffic,
                 x='Port Name',
                 y='Measure',
                 size='Value',
                 color='Value',
                 hover_name='Port Name',
                 title="Traffic by Port and Measure",
                 color_continuous_scale=px.colors.sequential.Viridis)

fig.update_layout(
    title_font_size=20,
    xaxis_title='Port Name',
    yaxis_title='Measure (Buses, Trucks, Pedestrians, etc.)',
    template='plotly_dark'
)
fig.show()

import plotly.express as px

# Summarize traffic data for each port and measure
port_traffic = df.groupby(['Port Name', 'Measure'])['Value'].sum().reset_index()

# Bubble plot using Plotly Express
fig = px.scatter(port_traffic,
                 x='Port Name',
                 y='Measure',
                 size='Value',
                 color='Value',
                 hover_name='Port Name',
                 title="Traffic by Port and Measure",
                 color_continuous_scale=px.colors.sequential.Viridis)

# Update layout for better readability
fig.update_layout(
    title_font_size=20,
    xaxis_title='Port Name',
    yaxis_title='Measure (Buses, Trucks, Pedestrians, etc.)',
    template='plotly_dark',
    showlegend=True
)

# Save the plot as an HTML file
fig.write_html("traffic_by_port_and_measure.html")

# Show the plot
fig.show()

# Aggregate traffic by Measure
traffic_composition = df.groupby('Measure')['Value'].sum()

# Pie chart
plt.figure(figsize=(8, 8))
plt.pie(traffic_composition, labels=traffic_composition.index, autopct='%1.1f%%', startangle=140, colors=sns.color_palette('Set3'))
plt.title('Traffic Composition by Measure', fontsize=16, fontweight='bold')
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Convert 'Date' column to datetime objects
df['Date'] = pd.to_datetime(df['Date'])

# Extract year and month
df['Year'] = df['Date'].dt.year
df['Month'] = df['Date'].dt.month

# Group traffic by Year-Month
monthly_traffic = df.groupby(['Year', 'Month'])['Value'].sum().reset_index()

# Create a pivot table for plotting
pivot_df = monthly_traffic.pivot(index='Month', columns='Year', values='Value')

# Line plot
plt.figure(figsize=(12, 6))
sns.lineplot(data=pivot_df, dashes=False, palette="Set2", linewidth=2.5)
plt.title('Monthly Border Traffic Trends (Yearly Comparison)', fontsize=16, fontweight='bold')
plt.xlabel('Month', fontsize=14)
plt.ylabel('Total Traffic Volume', fontsize=14)
plt.xticks(ticks=range(1, 13), labels=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Aggregate traffic by Measure
traffic_composition = df.groupby('Measure')['Value'].sum()

# Sort traffic in descending order for better visual appeal
traffic_composition = traffic_composition.sort_values(ascending=False)

# Define colors and explode the largest category for emphasis
colors = sns.color_palette('Set3', len(traffic_composition))
explode = [0.05 if i == 0 else 0 for i in range(len(traffic_composition))]  # Slightly "explode" the largest section

# Pie chart
plt.figure(figsize=(10, 10))  # Increased figure size for better readability
wedges, texts, autotexts = plt.pie(
    traffic_composition,
    labels=traffic_composition.index,
    autopct=lambda p: f'{p:.1f}%\n({p*traffic_composition.sum() / 100:,.0f})',  # Show % and actual value
    startangle=140,
    colors=colors,
    explode=explode,
    pctdistance=0.85  # Position of percentage text inside the chart
)

# Customizing text properties for better readability
for text in texts:
    text.set_fontsize(12)
    text.set_fontweight('bold')

for autotext in autotexts:
    autotext.set_fontsize(11)
    autotext.set_color('black')

# Add a central circle to create a "donut" chart effect
centre_circle = plt.Circle((0, 0), 0.70, fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

# Chart title with improved font size and weight
plt.title('Traffic Composition by Measure', fontsize=18, fontweight='bold')

plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Aggregate traffic by Measure
traffic_composition = df.groupby('Measure')['Value'].sum()

# Pie chart
plt.figure(figsize=(8, 8))
plt.pie(traffic_composition,
        labels=traffic_composition.index,
        autopct='%1.1f%%',
        startangle=140,
        colors=sns.color_palette('Set3'),
        wedgeprops={'edgecolor': 'black', 'linewidth': 1.5},  # Adding edge color for better contrast
        pctdistance=0.85)  # Adjust the percentage distance from the center

# Adding a central circle to create a donut chart look
centre_circle = plt.Circle((0,0),0.70,fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

# Title and other visual improvements
plt.title('Traffic Composition by Measure', fontsize=16, fontweight='bold')
plt.tight_layout()

# Show plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Aggregate traffic by Measure
traffic_composition = df.groupby('Measure')['Value'].sum()

# Pie chart with better label positioning
plt.figure(figsize=(8, 8))
plt.pie(traffic_composition,
        labels=traffic_composition.index,
        autopct='%1.1f%%',
        startangle=140,
        colors=sns.color_palette('Set3'),
        wedgeprops={'edgecolor': 'black', 'linewidth': 1.5},  # Adding edge color for better contrast
        pctdistance=0.85,  # Adjusting percentage distance from the center
        labeldistance=1.1)  # Increased distance for labels

# Adding a central circle to create a donut chart look
centre_circle = plt.Circle((0,0),0.70,fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

# Title and other visual improvements
plt.title('Traffic Composition by Measure', fontsize=16, fontweight='bold')
plt.tight_layout()

# Show plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Aggregate traffic by Measure
traffic_composition = df.groupby('Measure')['Value'].sum()

# Pie chart with better label positioning
plt.figure(figsize=(8, 8))

# Exploding the largest segment to make space for labels
explode = [0.1 if i == traffic_composition.idxmax() else 0 for i in traffic_composition.index]

# Create the pie chart
plt.pie(traffic_composition,
        labels=traffic_composition.index,
        autopct='%1.1f%%',
        startangle=140,
        colors=sns.color_palette('Set3'),
        wedgeprops={'edgecolor': 'black', 'linewidth': 1.5},  # Adding edge color for better contrast
        pctdistance=0.85,  # Adjusting percentage distance from the center
        labeldistance=1.1,  # Increasing distance for labels to reduce overlap
        explode=explode)  # Exploding the largest segment to reduce overlap

# Adding a central circle to create a donut chart look
centre_circle = plt.Circle((0,0),0.70,fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

# Title and other visual improvements
plt.title('Traffic Composition by Measure', fontsize=16, fontweight='bold')

# Adjust the layout to prevent text from overlapping
plt.tight_layout()

# Show plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Aggregate traffic by Measure
traffic_composition = df.groupby('Measure')['Value'].sum()

# Create the pie chart with no labels directly on the segments
plt.figure(figsize=(8, 8))

# Exploding the largest segment to make space for labels
explode = [0.1 if i == traffic_composition.idxmax() else 0 for i in traffic_composition.index]

# Create the pie chart without labels
wedges, texts, autotexts = plt.pie(traffic_composition,
                                   autopct='%1.1f%%',
                                   startangle=140,
                                   colors=sns.color_palette('Set3'),
                                   wedgeprops={'edgecolor': 'black', 'linewidth': 1.5},
                                   pctdistance=0.85,
                                   explode=explode)

# Add a central circle to make it a donut chart look
centre_circle = plt.Circle((0, 0), 0.70, fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

# Add labels and descriptions as a legend to avoid overlap
labels = traffic_composition.index
plt.legend(wedges, labels, title="Measures", loc="upper left", fontsize=12, frameon=False)

# Title and other visual improvements
plt.title('Traffic Composition by Measure', fontsize=16, fontweight='bold')

# Adjust layout to fit everything
plt.tight_layout()

# Show plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Aggregate traffic by Measure
traffic_composition = df.groupby('Measure')['Value'].sum()

# Create the pie chart with no labels directly on the segments
plt.figure(figsize=(8, 8))

# Exploding the largest segment to make space for labels
explode = [0.1 if i == traffic_composition.idxmax() else 0 for i in traffic_composition.index]

# Create the pie chart without labels
wedges, texts, autotexts = plt.pie(traffic_composition,
                                   autopct='%1.1f%%',
                                   startangle=140,
                                   colors=sns.color_palette('Set3'),
                                   wedgeprops={'edgecolor': 'black', 'linewidth': 1.5},
                                   pctdistance=0.85,
                                   explode=explode)

# Add a central circle to make it a donut chart look
centre_circle = plt.Circle((0, 0), 0.70, fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

# Adjust the placement of the legend to avoid overlap
plt.legend(wedges, traffic_composition.index, title="Measures", loc="upper left", fontsize=12, frameon=False, bbox_to_anchor=(1.05, 1))

# Title and other visual improvements
plt.title('Traffic Composition by Measure', fontsize=16, fontweight='bold')

# Adjust layout to make space for the legend
plt.tight_layout()

# Show plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Aggregate traffic by Measure
traffic_composition = df.groupby('Measure')['Value'].sum()

# Create the pie chart with no labels directly on the segments
plt.figure(figsize=(8, 8))

# Exploding the largest segment to make space for labels
explode = [0.1 if i == traffic_composition.idxmax() else 0 for i in traffic_composition.index]

# Create the pie chart without labels
wedges, texts, autotexts = plt.pie(traffic_composition,
                                   autopct='%1.1f%%',
                                   startangle=140,
                                   colors=sns.color_palette('Set3'),
                                   wedgeprops={'edgecolor': 'black', 'linewidth': 1.5},
                                   pctdistance=0.85,
                                   explode=explode)

# Add a central circle to make it a donut chart look
centre_circle = plt.Circle((0, 0), 0.70, fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

# Create the legend with percentages
legend_labels = [f'{label}: {percentage:.1f}%' for label, percentage in zip(traffic_composition.index, 100 * traffic_composition / traffic_composition.sum())]

# Adjust the placement of the legend to avoid overlap
plt.legend(wedges, legend_labels, title="Measures", loc="upper left", fontsize=12, frameon=False, bbox_to_anchor=(1.05, 1))

# Title and other visual improvements
plt.title('Traffic Composition by Measure', fontsize=16, fontweight='bold')

# Adjust layout to make space for the legend
plt.tight_layout()

# Show plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Aggregate traffic by Measure
traffic_composition = df.groupby('Measure')['Value'].sum()

# Create the pie chart without displaying percentages on the chart
plt.figure(figsize=(8, 8))

# Exploding the largest segment to make space for labels
explode = [0.1 if i == traffic_composition.idxmax() else 0 for i in traffic_composition.index]

# Create the pie chart without percentages on the segments
wedges, texts = plt.pie(traffic_composition,
                        startangle=140,
                        colors=sns.color_palette('Set3'),
                        wedgeprops={'edgecolor': 'black', 'linewidth': 1.5},
                        pctdistance=0.85,
                        explode=explode)

# Add a central circle to make it a donut chart look
centre_circle = plt.Circle((0, 0), 0.70, fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

# Create the legend with percentages
legend_labels = [f'{label}: {percentage:.1f}%' for label, percentage in zip(traffic_composition.index, 100 * traffic_composition / traffic_composition.sum())]

# Adjust the placement of the legend to avoid overlap
plt.legend(wedges, legend_labels, title="Measures", loc="upper left", fontsize=12, frameon=False, bbox_to_anchor=(1.05, 1))

# Title and other visual improvements
plt.title('Traffic Composition by Measure', fontsize=16, fontweight='bold')

# Adjust layout to make space for the legend
plt.tight_layout()

# Show plot
plt.show()

